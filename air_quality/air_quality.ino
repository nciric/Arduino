#include <Adafruit_GFX.h>
#include <Adafruit_GrayOLED.h>
#include <Adafruit_SPITFT.h>
#include <Adafruit_SPITFT_Macros.h>
#include <gfxfont.h>

#include <Adafruit_SSD1306.h>
#include <splash.h>

#include "PMS.h"
#include "arduino_secrets.h"
#include "thingProperties.h"

/*
  Sketch generated by the Arduino IoT Cloud Thing "PMS7003Sensor"
  https://create.arduino.cc/cloud/things/7bc24c98-59a3-45ff-bb5a-0eeede40233f

  Arduino IoT Cloud Properties description

  The following variables are automatically generated and updated when changes are made to the Thing properties

  float pm_10_0_avg;
  float pm_2_5_avg;
  int air_quality;

  Properties which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/

// Holds AQI range values from
// https://en.wikipedia.org/wiki/Air_quality_index#Indices_by_location (US)
typedef struct {
  float c_low;
  float c_high;
  int i_low;
  int i_high;
} Aqi;

// Max AQI value (if shown then we are out of some bounds).
int MAX_AQI = 666;

// Keep a sliding window of values to stabilize the reading.
// First PM_WINDOW_LEN cycles will give bogus result, since average is skewed by 0.0 values.
const int PM_WINDOW_LEN = 20;
float pm_2_5_window[PM_WINDOW_LEN] = {0.0};
float pm_10_0_window[PM_WINDOW_LEN] = {0.0};

PMS pms(Serial1);
PMS::DATA data;

Adafruit_SSD1306 display(128, 64);

unsigned long previousMillis = 0;
// Refreshes the display once every 1000ms without holding up the Arduino processor like delay() does.
// If you use a delay(), the PMSX003 will produce checksum errors.
const unsigned long kInterval = 1000;

// Leading zero result.
const int MAX_DIGIT = 3;
char number[MAX_DIGIT + 1];

void setup() {
  // Setup screen port.
  display.begin(SSD1306_SWITCHCAPVCC, 0x3C);
  display.display();

  // Wait for serial monitor to come up, but don't fail if it doesn't.
  Serial.begin(9600);

  // This one talks to the sensor, so we have to wait for it.
  Serial1.begin(9600);
  while (!Serial1) delay(10);

  delay(1500);
  Serial.println("PMSX003 Air Quality Sensor");

  // Defined in thingProperties.h
  initProperties();

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);

  /*
     The following function allows you to obtain more information
     related to the state of network and IoT Cloud connection and errors
     the higher number the more granular information youâ€™ll get.
     The default is 0 (only errors).
     Maximum is 4
  */
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();
}

void loop() {
  if (pms.read(data)) {
    Serial.println("===============");
    Serial.println("PM1.0 :" + String(data.PM_AE_UG_1_0) + "(ug/m3)");
    Serial.println("PM2.5 :" + String(data.PM_AE_UG_2_5) + "(ug/m3)");
    Serial.println("PM10  :" + String(data.PM_AE_UG_10_0) + "(ug/m3)");
    update_2_5_window(data.PM_AE_UG_2_5);
    update_10_0_window(data.PM_AE_UG_10_0);
  }

  // Make all measurements, then take max AQI value.
  pm_2_5_avg = average_2_5();
  int aqi_2_5_value = aqi_2_5(pm_2_5_avg);

  pm_10_0_avg = average_10_0();
  int aqi_10_0_value = aqi_10(pm_10_0_avg);

  air_quality = std::max(aqi_2_5_value, aqi_10_0_value);
  ArduinoCloud.update();

  // Non-blocking code for displaying the sensor readings.
  unsigned long currentMillis = millis();
  if (currentMillis - previousMillis > kInterval) {
    previousMillis = currentMillis;

    display.clearDisplay();
    // Fits three digits on the screen.
    display.setTextSize(7);
    display.setTextColor(WHITE);
    display.setCursor(2,10);
  
    sprintf(number, "%03d", air_quality);
    display.println(number);
  
    // Update screen.
    display.display();
  }
}

// AQI value to be shown on display.
int get_aqi(Aqi, float);

int aqi_2_5(float pm_ug_2_5) {
  Aqi table[] = {
    {0.0, 12.0, 0, 50},
    {12.1, 35.4, 51, 100},
    {35.5, 55.4, 101, 150},
    {55.5, 150.4, 151, 200},
    {150.5, 250.4, 201, 300},
    {250.5, 350.4, 301, 400},
    {350.5, 500.4, 401, 500},
  };
  int len = sizeof(table) / sizeof(table[0]);
  for (int i = 0; i < len; ++i) {
    if (table[i].c_low <= pm_ug_2_5 && pm_ug_2_5 <= table[i].c_high) {
      return get_aqi(table[i], pm_ug_2_5);
    }
  }
  // It's not air we breath anymore...
  return MAX_AQI;
}

int aqi_10(float pm_ug_10_0) {
  Aqi table[] = {
    {0.0, 54.0, 0, 50},
    {54.1, 154.0, 51, 100},
    {154.1, 254.0, 101, 150},
    {254.1, 354.0, 151, 200},
    {354.1, 424.0, 201, 300},
    {424.1, 504.0, 301, 400},
    {504.1, 604.0, 401, 500},
  };
  int len = sizeof(table) / sizeof(table[0]);
  for (int i = 0; i < len; ++i) {
    if (table[i].c_low <= pm_ug_10_0 && pm_ug_10_0 <= table[i].c_high) {
      return get_aqi(table[i], pm_ug_10_0);
    }
  }
  // It's not air we breath anymore...
  return MAX_AQI;
}

int get_aqi(Aqi aqi, float reading) {
  // Formula from https://en.wikipedia.org/wiki/Air_quality_index#Indices_by_location
  // US region.
  float result = (aqi.i_high - aqi.i_low) * (reading - aqi.c_low) / (aqi.c_high - aqi.c_low) + aqi.i_low;
  if (result < 0.0) {
    return 0;
  } else {
    return static_cast<int>(result);
  }
}

void update_2_5_window(float value) {
  static int cursor = 0;
  pm_2_5_window[cursor] = value;
  if (cursor >= PM_WINDOW_LEN) {
    cursor = 0;
  } else {
    cursor++;
  }
}

void update_10_0_window(float value) {
  static int cursor = 0;
  pm_10_0_window[cursor] = value;
  if (cursor >= PM_WINDOW_LEN) {
    cursor = 0;
  } else {
    cursor++;
  }
}

float average_2_5() {
  float sum = 0.0;
  for (int i = 0; i < PM_WINDOW_LEN; ++i) {
    sum += pm_2_5_window[i];
  }
  return sum / PM_WINDOW_LEN;
}

float average_10_0() {
  float sum = 0.0;
  for (int i = 0; i < PM_WINDOW_LEN; ++i) {
    sum += pm_10_0_window[i];
  }
  return sum / PM_WINDOW_LEN;
}
